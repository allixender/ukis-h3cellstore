use crate::clickhouse::compacted_tables::{Table, TableSet, TableSpec, COL_NAME_H3INDEX};
use crate::Error;
use arrow_h3::h3ron::collections::{HashMap, HashSet};
use arrow_h3::h3ron::iter::change_resolution;
use arrow_h3::h3ron::{H3Cell, Index, H3_MIN_RESOLUTION};
use tracing::error;

#[derive(Clone)]
pub enum TableSetQuery {
    /// autogenerate a query based on the available columns
    AutoGenerated,

    /// templated select statement
    ///
    /// The selected columns must include the h3indexes in a column named `h3index`
    ///
    /// The query must include these placeholders:
    /// * "<[table]>": will be filled with the table to be queried
    /// * "<[h3indexes]>": will be filled with an array of h3indexes used for the query
    ///
    /// TODO: parsing and validating and injecting missing column into the query with https://github.com/ballista-compute/sqlparser-rs
    ///    would be nice, but as the parser does not implement a clickhouse dialect, its is probably more
    ///    error prone than it is beneficial.
    TemplatedSelect(String),
}

impl TableSetQuery {
    pub fn validate(&self) -> Result<(), Error> {
        match self {
            TableSetQuery::AutoGenerated => Ok(()),
            TableSetQuery::TemplatedSelect(querystring) => {
                for placeholder in &["<[table]>", "<[h3indexes]>"] {
                    if !querystring.contains(placeholder) {
                        return Err(Error::MissingQueryPlaceholder(placeholder.to_string()));
                    }
                }
                Ok(())
            }
        }
    }
}

impl From<Option<String>> for TableSetQuery {
    fn from(instr: Option<String>) -> Self {
        match instr {
            Some(s) => Self::TemplatedSelect(s),
            None => Self::AutoGenerated,
        }
    }
}

pub trait BuildQuery {
    type QueryInput;

    /// build a select query for the given h3 cells.
    ///
    /// Will also fetch the parent, compacted indexes.
    fn build_cell_query_string(
        &self,
        query: &Self::QueryInput,
        h3_resolution: u8,
        h3cells: &[H3Cell],
    ) -> Result<String, Error>;
}

impl BuildQuery for TableSet {
    type QueryInput = TableSetQuery;

    fn build_cell_query_string(
        &self,
        query: &Self::QueryInput,
        h3_resolution: u8,
        h3cells: &[H3Cell],
    ) -> Result<String, Error> {
        if !self.base_tables.contains_key(&h3_resolution) {
            error!(
                "Resolution {} is not a part of the base tables of tableset {}",
                h3_resolution, self.basename
            );
            return Err(Error::NoQueryableTables);
        }
        if h3cells.is_empty() {
            return Err(Error::EmptyCells);
        };
        query.validate()?;

        // collect the indexes and the parents (where the tables exist)
        let queryable_h3indexes = collect_queryable_h3indexes(self, h3cells, h3_resolution)?;
        if queryable_h3indexes.is_empty() {
            return Err(Error::NoQueryableTables);
        }

        let query_string = {
            let selectable_columns = itertools::join(
                self.columns
                    .iter()
                    .map(|(col_name, _)| col_name)
                    .filter(|col_name| !col_name.starts_with(COL_NAME_H3INDEX)),
                ", ",
            );

            let mut query_string_parts = Vec::new();
            for r in H3_MIN_RESOLUTION..=h3_resolution {
                if let Some(query_h3indexes) = queryable_h3indexes.get(&r) {
                    let query_h3indexesarray_string = format!(
                        "[{}]",
                        itertools::join(query_h3indexes.iter().map(|hi| hi.to_string()), ",",)
                    );

                    let tablename = Table {
                        basename: self.basename.clone(),
                        spec: TableSpec {
                            h3_resolution: r,
                            is_compacted: r != h3_resolution,
                            temporary_key: None,
                            has_base_suffix: if r != h3_resolution {
                                &self.compacted_tables
                            } else {
                                &self.base_tables
                            }
                            .get(&r)
                            .map_or_else(|| true, |table_spec| table_spec.has_base_suffix),
                        },
                    }
                    .to_table_name();

                    query_string_parts.push(match &query {
                        TableSetQuery::AutoGenerated => {
                            format!(
                                "select {}, {} from {} where {} in {}",
                                COL_NAME_H3INDEX,
                                selectable_columns,
                                tablename,
                                COL_NAME_H3INDEX,
                                query_h3indexesarray_string
                            )
                        }
                        TableSetQuery::TemplatedSelect(query_string) => query_string
                            .replace("<[table]>", &tablename)
                            .replace("<[h3indexes]>", &query_h3indexesarray_string),
                    });
                }
            }

            itertools::join(query_string_parts.iter(), " union all ")
        };
        Ok(query_string)
    }
}

/// collect the indexes and the parents (where the tables exist)
fn collect_queryable_h3indexes(
    tableset: &TableSet,
    cells: &[H3Cell],
    query_h3_resolution: u8,
) -> Result<HashMap<u8, HashSet<u64>>, Error> {
    let mut queryable_h3indexes: HashMap<_, HashSet<_>> = tableset
        .base_tables
        .iter()
        .chain(tableset.compacted_tables.iter())
        .filter(|(r, _)| **r <= query_h3_resolution)
        .map(|(r, _)| (*r, HashSet::new()))
        .collect();

    for (resolution, queryable_h3indexes_set) in queryable_h3indexes.iter_mut() {
        let mut h3indexes_at_resolution = change_resolution(cells, *resolution)
            .map(|cell_res| cell_res.map(|cell| cell.h3index()))
            .collect::<Result<Vec<_>, _>>()?;
        h3indexes_at_resolution.sort_unstable();
        h3indexes_at_resolution.dedup();

        queryable_h3indexes_set.extend(h3indexes_at_resolution.iter());
    }
    Ok(queryable_h3indexes)
}
