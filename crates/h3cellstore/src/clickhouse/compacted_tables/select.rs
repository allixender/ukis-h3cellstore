use tracing::error;

use arrow_h3::export::h3ron::collections::{HashMap, HashSet};
use arrow_h3::export::h3ron::iter::change_resolution;
use arrow_h3::export::h3ron::{H3Cell, Index, H3_MIN_RESOLUTION};

use crate::clickhouse::compacted_tables::{Table, TableSet, TableSpec, COL_NAME_H3INDEX};
use crate::Error;

#[derive(Clone)]
pub enum TableSetQuery {
    /// autogenerate a query based on the available columns
    AutoGenerated,

    /// templated select statement
    ///
    /// The selected columns must include the h3indexes in a column named `h3index`
    ///
    /// The query must include these placeholders:
    /// * "<[table]>": will be filled with the table to be queried
    ///
    /// TODO: parsing and validating and injecting missing column into the query with https://github.com/ballista-compute/sqlparser-rs
    ///    would be nice, but as the parser does not implement a clickhouse dialect, its is probably more
    ///    error prone than it is beneficial.
    TemplatedSelect(String),
}

impl TableSetQuery {
    pub fn validate(&self) -> Result<(), Error> {
        match self {
            TableSetQuery::AutoGenerated => Ok(()),
            TableSetQuery::TemplatedSelect(querystring) => {
                for placeholder in &["<[table]>"] {
                    if !querystring.contains(placeholder) {
                        return Err(Error::MissingQueryPlaceholder(placeholder.to_string()));
                    }
                }
                Ok(())
            }
        }
    }
}

impl From<Option<String>> for TableSetQuery {
    fn from(instr: Option<String>) -> Self {
        match instr {
            Some(s) => Self::TemplatedSelect(s),
            None => Self::AutoGenerated,
        }
    }
}

impl Default for TableSetQuery {
    fn default() -> Self {
        Self::AutoGenerated
    }
}

pub trait BuildCellQueryString {
    /// build a select query for the given h3 cells.
    ///
    /// Will also fetch the parent, compacted indexes.
    fn build_cell_query_string(
        &self,
        tableset: &TableSet,
        h3_resolution: u8,
        h3cells: &[H3Cell],
    ) -> Result<String, Error>;
}

impl BuildCellQueryString for TableSetQuery {
    fn build_cell_query_string(
        &self,
        tableset: &TableSet,
        h3_resolution: u8,
        h3cells: &[H3Cell],
    ) -> Result<String, Error> {
        if !tableset.base_tables.contains_key(&h3_resolution) {
            error!(
                "Resolution {} is not a part of the base tables of tableset {}",
                h3_resolution, tableset.basename
            );
            return Err(Error::NoQueryableTables);
        }
        if h3cells.is_empty() {
            return Err(Error::EmptyCells);
        };
        self.validate()?;

        // collect the indexes and the parents (where the tables exist)
        let queryable_h3indexes = collect_queryable_h3indexes(tableset, h3cells, h3_resolution)?;
        if queryable_h3indexes.is_empty() {
            return Err(Error::NoQueryableTables);
        }

        let query_string = {
            let selectable_columns = itertools::join(
                tableset
                    .columns
                    .iter()
                    .map(|(col_name, _)| col_name)
                    .filter(|col_name| !col_name.starts_with(COL_NAME_H3INDEX)),
                ", ",
            );

            let mut query_string_parts = Vec::new();
            for r in H3_MIN_RESOLUTION..=h3_resolution {
                if let Some(query_h3indexes) = queryable_h3indexes.get(&r) {
                    let query_h3indexesarray_string = format!(
                        "[{}]",
                        itertools::join(query_h3indexes.iter().map(|hi| hi.to_string()), ",",)
                    );

                    let tablename = Table {
                        basename: tableset.basename.clone(),
                        spec: TableSpec {
                            h3_resolution: r,
                            is_compacted: r != h3_resolution,
                            temporary_key: None,
                            has_base_suffix: if r != h3_resolution {
                                &tableset.compacted_tables
                            } else {
                                &tableset.base_tables
                            }
                            .get(&r)
                            .map_or_else(|| true, |table_spec| table_spec.has_base_suffix),
                        },
                    }
                    .to_table_name();

                    query_string_parts.push(match self {
                        TableSetQuery::AutoGenerated => {
                            format!(
                                "select {}, {} from {} where {} in {}",
                                COL_NAME_H3INDEX,
                                selectable_columns,
                                tablename,
                                COL_NAME_H3INDEX,
                                query_h3indexesarray_string
                            )
                        }
                        TableSetQuery::TemplatedSelect(query_string) => {
                            query_string.replace("<[table]>", &tablename)
                        }
                    });
                }
            }

            itertools::join(query_string_parts.iter(), " union all ")
        };
        Ok(query_string)
    }
}

/// collect the indexes and the parents (where the tables exist)
fn collect_queryable_h3indexes(
    tableset: &TableSet,
    cells: &[H3Cell],
    query_h3_resolution: u8,
) -> Result<HashMap<u8, HashSet<u64>>, Error> {
    let mut queryable_h3indexes: HashMap<_, HashSet<_>> = tableset
        .base_tables
        .iter()
        .chain(tableset.compacted_tables.iter())
        .filter(|(r, _)| **r <= query_h3_resolution)
        .map(|(r, _)| (*r, HashSet::new()))
        .collect();

    for (resolution, queryable_h3indexes_set) in queryable_h3indexes.iter_mut() {
        let mut h3indexes_at_resolution = change_resolution(cells, *resolution)
            .map(|cell_res| cell_res.map(|cell| cell.h3index()))
            .collect::<Result<Vec<_>, _>>()?;
        h3indexes_at_resolution.sort_unstable();
        h3indexes_at_resolution.dedup();

        queryable_h3indexes_set.extend(h3indexes_at_resolution.iter());
    }
    Ok(queryable_h3indexes)
}
